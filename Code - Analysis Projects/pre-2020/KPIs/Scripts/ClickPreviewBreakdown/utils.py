import matplotlib.pyplot as plt
import numpy as np
import os
import pandas as pd
import psycopg2
from collections import OrderedDict


def load_connection():
    user = os.environ.get('DB_USER')
    pwd = os.environ.get('DB_PW')
    db = os.environ.get('DB_NAME')
    host = os.environ.get('DB_HOST')
    return psycopg2.connect(database=db, user=user, password=pwd, host=host)


def plot_previews_stacked_bar(
        ser, ax, color_dict, title, ylabel='Percentage of Previews'):
    ser = pd.Series(ser)
    left = 1
    bottom = 0
    current_idx = None
    for idx, val in zip(ser.index, ser.values):
        if current_idx is None:
            current_idx = idx[0]
        if idx[0] != current_idx:
            current_idx = idx[0]
            left += 1
            bottom = 0

        ax.bar(
            x=left,
            height=val,
            bottom=bottom,
            color=color_dict[idx[1]],
            width=0.5,
            label=idx[1],
        )
        text = '%d' % np.round(val * 100) + '%'
        ax.text(left - 0.05, bottom + (val / 2), s=text)
        bottom += val

    handles, labels = ax.get_legend_handles_labels()
    by_label = OrderedDict(zip(labels, handles))
    ax.legend(
        by_label.values(),
        by_label.keys(),
        loc='lower center',
        bbox_to_anchor=(0.5, -0.1),
        ncol=2
    )
    ax.set_xticks([1, 2])
    ax.set_xticklabels(['android', 'ios'])
    ax.set_ylabel(ylabel)
    ax.set_title(title)


def plot_interactions_stacked_bar(
        ser, ax, color_dict, title, ylabel='Percentage of Interactions'):
    ser = pd.Series(ser)
    left = 1
    bottom = 0
    for idx, val in zip(ser.index, ser.values):
        ax.bar(
            x=left,
            height=val,
            bottom=bottom,
            color=color_dict[idx],
            width=0.5,
            label=idx,
        )
        
        text = '%d' % np.round(val * 100) + '%'
        ax.text(left - 0.05, bottom + (val / 2), s=text)
        bottom += val

    handles, labels = ax.get_legend_handles_labels()
    by_label = OrderedDict(zip(labels, handles))
    ax.legend(by_label.values(), by_label.keys(),
               loc='lower center', bbox_to_anchor=(0.5, -0.15), ncol=2)
    ax.set_xticks([left])
    ax.set_xticklabels([''])
    ax.set_xlim(0, 2)
    ax.set_ylabel(ylabel)
    ax.set_title(title)


def create_label(df):
    if df['activity_bucket'] in ['click', 'preview']:
        return str(df['activity_bucket']) + '_' + str(df['os'])
    else:
        return 'unclassified/bot'


# group by functions
def num_previews(ua_bucket):
    if len(ua_bucket) > 1:
        return(len(ua_bucket[ua_bucket.str.contains('preview')]))
    return 1


def calc_avg_time_betw_clicks(time_ser):
    if len(time_ser) > 1:
        time_betw = time_ser - time_ser.shift()
        return time_betw.mean()
    return 'nan'


def contains_preview(val):
    if 'preview' in val:
        return 1
    for v in val:
        if 'preview' in v:
            return 1
    return 0


def contains_click(val):
    if 'click' in val:
        return 1
    for v in val:
        if 'click' in v:
            return 1
    return 0


def contains_multiple_os(val):
    if 'bot' in val:
        return 2
    if 'ios' in val and 'android' in val:
        return 1
    if 'ios' in val and 'unclassified' in val:
        return 1
    if 'unclassified' in val and 'android' in val:
        return 1
    else:
        return 0


def user_monthly_activity(preview_bucket_ser):
    if 'click' in preview_bucket_ser.values:
        return 'click'
    elif ('autogenerated' in preview_bucket_ser.values) or (
            'tap-to-load' in preview_bucket_ser.values):
        return 'preview'
    else:
        return 'unclassified/bot'


def user_preview_activity(preview_bucket_ser):
    if 'tap-to-load' in preview_bucket_ser.values:
        return 'tap-to-load'
    elif 'autogenerated' in preview_bucket_ser.values:
        return 'autogenerated'
    else:
        return None


def return_os(ua_bucket_ser):
    if len(ua_bucket_ser[ua_bucket_ser.str.contains('click')]) > 0:
        return ua_bucket_ser[
            ua_bucket_ser.str.contains('click')].iloc[0].split('_')[1]
    if len(ua_bucket_ser[ua_bucket_ser.str.contains('preview')]) > 0:
        return ua_bucket_ser[
            ua_bucket_ser.str.contains('preview')].iloc[0].split('_')[1]
    else:
        return 'unclassified/bot'
